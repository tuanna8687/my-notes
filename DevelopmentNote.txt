
1. PDB File
	- This file is very important when you want to debug a assembly. You must have this file along with the EXE/DLL to be able to debug.
	- 2 executables could have same source code but different pdb
	- https://www.wintellect.com/pdb-files-what-every-developer-must-know/
	
2. User code vs non-user code
	- It impacts to "Enable Just My Code" option in VS
	- To distinguish user code from non-user code, Just My Code looks at symbol (.pdb) files and program optimizations. The debugger considers code to be non-user code when the binary is optimized or when the .pdb file is not available.
	- https://msdn.microsoft.com/en-us/library/dn457346.aspx
	- https://blogs.msdn.microsoft.com/zainnab/2010/10/25/understanding-just-my-code/
	- For example:
		+ I write my web application that uses a nuget package named PackageA
		+ If I have source code of the PackageA and I compile the source code with Debug mode (code is not optimized and PDB is generated)
		+ Now I can debug the PackageA without uncheck "Enable Just My Code". Because debugger considers PackageA as user code
		+ But if I compile the source code PackageA with Release mode (code is optimized and PDB is generated)
		+ I only debug the PackageA when uncheck "Enable Just My Code". Because debugger considers PackageA as non-user code

3. You can debug a release version of a DLL (with PDB file) but it does not smoothly: https://stackoverflow.com/questions/769995/debugging-a-release-version-of-a-dll-with-pdb-file

4. To debug a assembly (EXE/DLL) we must have:
	- EXE/DLL file
	- PDB file (can generated by tool as dotPeek as well as download from symbols server)
	- Source code (can generated by tool as reshaper, etc.)
	
5. Debug ASP.NET Core source code: https://www.stevejgordon.co.uk/debugging-asp-net-core-2-source

6. Debug a ASP.NET Core module for example: Microsoft.AspNetCore.Authentication.dll
	- Find source code of the DLL on github (or generated from tools such as Reshaper). The source code of the same version as DLL
	- Compile the source code with "Debug" mode to generate a new DLL along with PDB file
	- Copy the new DLL & PDB file into the folder of app or process you want to attach to debug
	- Open source code of the DLL in VS and attach the process to debug
	- Must make sure that the symbol for the DLL is loaded --> using Modules window in VS Debugger
	
7. Specify Symbol (.pdb) and Source Files in the Visual Studio Debugger (https://msdn.microsoft.com/en-us/library/ms241613.aspx)
	- Where the debugger searches for .pdb files
		+ The location that is specified inside the DLL or the executable file. (By default, if you have built a DLL or an executable file on your computer, the linker places the full path and file name of the associated .pdb file inside the DLL or the executable file. The debugger first checks to see if the symbol file exists in the location that is specified inside the DLL or the executable file. This is helpful, because you always have symbols available for code that you have compiled on your computer.)
		+ .pdb files that could be present in the same folder as the DLL or executable file.
		+ Any local symbol cache folders.
		+ Any network, internet, or local symbol servers and locations that are specified on, such as the Microsoft symbol server if enabled.
	- Where the debugger searches for source files
		+ Files that are open in the IDE of the Visual Studio instance that launched the debugger.
		+ Files in the solution that is open in the Visual Studio instance.
		+ Directories that are specified in the Common Properties / Debug Source Files page in the properties of the solution. (In the Solution Explorer, select the solution node, right-click, and select Properties. )
		+ The source information of the .pdb of the module. This can be the location of the source file when the module was built, or it can be a command to a source server.
		
8. Git rebase (https://medium.freecodecamp.org/git-rebase-and-the-golden-rule-explained-70715eccc372)
	A <-- B <-- C <-- D (master)
			\
			 \ E <-- F (feature)
	Command: git rebase master feature --> Rebase the branch feature. A rebase will sequentially take all the commit from the branch (feature) you’re in, and reapply them to the destination (master)
9. Git folder (https://medium.freecodecamp.org/understanding-git-for-real-by-exploring-the-git-directory-1e079c15b807)
	- Every-time you create a file, and track it (move to staging area), git compresses it and stores it into its own data structure. The compressed object will have a unique name, a hash, and will be stored under the object directory.

10. T-SQL
	- Aggregate functions: COUNT, MAX, MIN, SUM, AVG
		+ If the query does not contains GROUP BY clause then scope of aggregate functions are on all data, it means that calculations are performed on all data row -> Result only has a column
		+ If the query contains GROUP BY clause then scope of aggregate functions are only on each group, it means that calcuationas are performed on each group -> Result has multiple columns corresponding to each group
	- WHERE clause can't use with aggregate functions
	- Only HAVING clause can use with aggregate functions -> It impacts to SELECT clause, it means that SELECT clause must perform a aggregate function or select columns belong to GROUP BY clause
		+ Similar to aggregate functions, if the query has only HAVING clause then HAVING condition apply on all data
		+ If the query has GROUP BY and HAVING clauses then HAVING condtion apply on each group
	- ALL, ANY (http://www.sqltutorial.org/sql-all/)